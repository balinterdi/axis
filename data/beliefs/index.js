module.exports = [
{id:'0', type:'conservative', title: 'Software should aim to be bug free before it launches.', body:  '(Banner claim: "Debugging Sucks!") Make sure your types and interfaces are all modeled, your tests are all written, and your system is fully specified before you launch. Or else be prepared for the worst!'},
{id:'1',type:'conservative', title: 'Programmers should be protected from errors.', body: 'Many language features are inherently error-prone and dangerous, and should be disallowed for all the code we write. We can get by without these features, and our code will be that much safer.'},
{id:'2',type:'conservative', title: 'Programmers have difficulty learning new syntax.', body: 'We should limit the number of languages used at our company, so that nobody has to learn a new syntax when a system goes down in the middle of the night on Christmas Eve. And we should never permit features that allow defining new syntax, nor changing the semantics of existing syntax. (Common examples: no operator overloading, and NO metaprogramming!)'},
{id:'3',type:'conservative', title: 'Production code must be safety-checked by a compiler.', body: 'Any code that cannot be statically checked should in general be avoided. In specific cases where it is strictly necessary, uses of it must be approved by a central committee. (Examples: eval, dynamic invocation, RTTI).'},
{id:'4',type:'conservative', title: 'Data stores must adhere to a well-defined, published schema.', body: ' Relational databases must be in third-normal form and adhere to a UML or equivalent schema definition. XML should have a DTD. NoSQL databases and name/value stores -- both of which should be avoided in general -- must have a separate physical schema that defines all permissible keys and their corresponding value types.'},
{id:'5',type:'conservative', title: 'Public interfaces should be rigorously modeled.', body: 'Data should never be stored in strings or untyped collections. All input and output entities should be thorougly and explicitly specified via statically-checkable, ideally object-oriented models.'},
{id:'6',type:'conservative', title: 'Production systems should never have dangerous or risky back-doors.', body:'It should never be possible to connect to a live production system via a debugger, telnet shell, nor any other interface that allows the developer to manipulate the runtime operation of the code or data. The only ports into a production system should be read-only monitoring channels.'},
{id:'7',type:'conservative', title: 'If there is ANY doubt as to the safety of a component, it cannot be allowed in production', body: '-- no matter how teams may cry and wail that they need it to make forward progress. (I\'m talkin\' to you, FUSE).'},
{id:'8',type:'conservative', title: 'Fast is better than slow. Everyone hates slow code.', body: 'Code should perform well. You should engineer all your code for optimum speed up front, right out of the box. Otherwise it might not be fast enough. Avoid using languages or DSLs or libraries that have a reputation for being slow.  Even if they\'re fast enough for your current purposes, the requirements (or callers) could change, and suddenly the software would be too slow!'},
{id:'9',type:'liberal', title:'Bugs are not a big deal.', body:' They happen anyway, no matter how hard you try to prevent them, and somehow life goes on. Good debuggers are awesome pieces of technology, and stepping through your code gives you insights you can\'t get any other way. Debugging and diagnosing are difficult arts, and every programmer should be competent with them. The Christmas Eve Outage scenario never, ever happens in practice -- that\'s what code freeze is for. Bugs are not a big deal! (This belief really may be the key dividing philosophy between Conservative and Liberal philosophies.)'},
{id:'10',type:'liberal', title:'Programmers are only newbies for a little while.', body:' The steady state for a programmer\'s career is being smart, knowledgeable, creative, resourceful and experienced. Putting a bunch of rules in place to protect newbies from doing harm (or being harmed) is incorrectly optimizing for the transient case instead of the steady state.'},
{id:'11',type:'liberal', title:'Programmers figure stuff out amazingly fast when their jobs depend on it.', body: 'People learn to read sheet music, braille, sign language, and all sorts of other semiotic frameworks. Hell, even gorillas can apparently do all that. Programmers don\'t need protection from syntax. They just need documentation and a little slack time to read up on it.'},
{id:'12',type:'liberal', title:'Succinctness is power. Code should be kept small. Period.', body: 'If your static checking tools can\'t reason about the code, then the checking needs to be made smarter (e.g. by incorporating runtime data) rather than making the code dumber.'},
{id:'13',type:'liberal', title:'Rigid schemas limit flexibility and slow down development.', body: 'Lightweight/partial/optional schemas are a better tradeoff. Moreover, the schema is often not well-understood until a lot of data is collected and a lot of use cases are thorougly exercised. So the schema should follow the code rather than precede it.'},
{id:'14',type:'liberal', title:'Public interfaces should above all else be simple, backward-compatible, and future-compatible.', body:'Rigorous modeling is just guessing at how the interface will need to evolve. It makes both forward- and backward-compatibility almost impossible, resulting in interface churn and customer unhappiness. Public interfaces should always do the simplest thing that could possibly work, and grow only as needed.'},
{id:'15',type:'liberal', title:'System flexibility can mean the difference between you getting the customer (or contract) vs. your competitor nabbing it instead.', body:' Security and safety risks in runtime production systems can be mitigated and controlled by logging, monitoring and auditing. There are plenty of existence-proofs of large systems with root-access backdoors and shells (e.g. RDBMS, online game servers) whose risk is controlled while still giving them world-class runtime flexibility.'},
{id:'16',type:'liberal', title:'Companies should take risks, embrace progress, and fiercely resist ossification.', body: 'It doesn\'t matter how big your business is: it must grow or die. If you want to stay competitive, you have to make a conscious, often painful effort to take risks. Which means you\'ll need good recovery techniques for the inevitable disasters. But you need those even if you don\'t take risks.  So take risks!'},
{id:'17',type:'liberal', title:'Premature optimization is the root of all evil.', body:' Get the code working first, focusing on correctness over performance, and on iterative prototyping over correctness. Only when your customers list latency as the top priority should you begin performing profiler-driven optimizations.'}
];
